
\section{Analysis}

For every expression or variable $x$ in a Javascript program,
we need to compute a set of possible types $T(v)$.
Types can be primitive --- \code{int}, \code{number}, \code{string},
\code{bool}, \code{null}
or \code{undefined} --- or object types --- equivalence classes for
Javascript objects.
The \code{int} type indicates a number expressible as a signed 32-bit integer,
and is subsumed by \code{number} --- \code{int} is added to all type
sets containing \code{number}.

Since the analysis runs in a browser as code is trying to execute,
both time and space are at a premium and must be minimized.
To be viable for deployment, the analysis must satisfy the following:

\begin{itemize}

\item Time and memory used must be linear in the size of the analyzed code.

\item Querying results for an expression must take near-constant time,
to avoid changing the performance characteristics of the compiler.

\item Results must be correct if only compiled code is analyzed.

\end{itemize}

Section~\ref{XXX} describes object types, Section~\ref{XXX} describes
generation of the type constraints which forms the static portion of
the analysis, and Section~\ref{XXX} describes type barriers and the
other runtime checks which form the dynamic portion of the analysis.

\subsection{Object Types}

TODO

\subsection{Type Constraints}

We model the semantics of Javascript and how types flow through the
program as constraints between type sets.
This modeling is {\it incomplete}: it does not account for all possible
behaviors of Javascript expressions and statements.
All behaviors excluded by the type constraints must be detected at runtime
and their effect on types in the program dynamically recorded.

We describe the constraints and checks required for a simplified form
of the language: assignment, addition, property accesses, element accesses,
and function calls between variables.

\subsubsection{\code{x = y}}

Assignments in Javascript are completely modeled by a subset constraint
$T(y) \subseteq T(x)$.

\begin{equation*}
\frac{t \in T(y)}{t \in T(x)}
\end{equation*}

\subsubsection{\code{x = y + z}}

Addition in Javascript is very complicated. It is defined for any
combination of values, can perform either a numeric addition or
string concatenation, and can even perform function calls if either of
its operands is an object (calling their \code{valueOf} or
\code{toString} members, producing a number or string).

Using incomplete modeling lets us cut through this complexity.
The vast majority of dynamic additions in Javascript programs (NUMBERS)
are adding two numbers or concatenating two strings.
We statically model exactly these cases, and use runtime checks to monitor
the results produced by adding other combinations of values,
at little runtime cost.

Rules for addition of number and string values are below.

\begin{equation*}
\frac{int \in T(y) ~~~ int \in T(z)}{int \in T(x)}
\end{equation*}

\begin{equation*}
\frac{number \in T(y) ~~~ int \in T(z)}{number \in T(x)}
~~~~
\frac{int \in T(y) ~~~ number \in T(z)}{number \in T(x)}
\end{equation*}

\begin{equation*}
\frac{string \in T(y)}{string \in T(x)}
~~~~
\frac{string \in T(z)}{string \in T(x)}
\end{equation*}

The above rules are themselves incomplete for addition of two integers:
the result will be marked as an integer, ignoring the possibility of
integer overflow.
When adding two integers overflows, the result is not expressible in
32 bits, and has type \code{number}.
Overflow is extremely rare, and accounting for it statically would require
us to mark the result of all additions as arbitrary numbers,
except in the limited cases where we can prove no overflow is possible.

Ignoring overflow statically forces us to use runtime checks when overflows
occur.
There is no extra runtime cost associated with these checks, as the code
generated for integer additions requires an overflow check regardless.

\subsubsection{\code{x = y.f}}

\begin{eqnarray*}
\frac{t \in T(y) ~~~ o = O(t) ~~~ t' \in T(prop(o,f))}{t' \in T(x)}
\end{eqnarray*}

\subsubsection{\code{y.f = x}}

\begin{eqnarray*}
\frac{t \in T(x) ~~~ t' \in T(y) ~~~ o = O(t')}{t \in T(prop(o,f))}
\end{eqnarray*}

\subsubsection{\code{x = y[z]}, \code{y[z] = x}}

\begin{eqnarray*}
\frac{t \in T(y) ~~~ o = O(t) ~~~ t' \in T(index(o))}{t' \in T(x)}
\end{eqnarray*}

\begin{eqnarray*}
\frac{t \in T(x) ~~~ t' \in T(y) ~~~ o = O(t')}{t \in T(index(o))}
\end{eqnarray*}

\subsubsection{\code{x = y(z)}}

\begin{eqnarray*}
\frac{f \in T(y) ~~~ F(f) ~~~ t \in T(z)}{t \in T(arg(f, 0))}
\end{eqnarray*}

\begin{eqnarray*}
\frac{f \in T(y) ~~~ F(f) ~~~ t \in T(retval(f))}{t \in T(x)}
\end{eqnarray*}

\subsection{Type Barriers}

TODO

As described in Section~\ref{XXX}, type barriers are a form of runtime
check designed to retain precision when a program contains polymorphic code.

TODO

For any subset constraint $A \subseteq B$, we are free to restrict
propagation of types which are in $A$ but have never been observed for $B$,
so long as we include a runtime check for values read into $B$ and update
it with any newly observed types.

The presence or absence of type barriers for a given subset constraint
is not monotonic with respect to the contents of the type sets in the program.
As new types are discovered, new type barriers may be required, but existing
ones may become unnecessary.
However, it is always safe to perform the runtime check for a given barrier,
albeit less efficient.

\subsection{Interpreter Warmup}

TODO

\subsection{Supplemental Analysis}

TODO
