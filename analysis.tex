
\section{Analysis}

For every expression $v$ in a Javascript program,
we need to compute a set of possible types $T(v)$.
Types can be primitive --- \code{int}, \code{number}, \code{string},
\code{bool}, \code{null}
or \code{undefined} --- or object types --- equivalence classes for
Javascript objects.
The \code{int} type indicates a number expressible as a signed 32-bit integer,
and is subsumed by \code{number} --- \code{int} is added to all type
sets containing \code{number}.
An additional type \code{unknown} indicates a type set whose contents
could be anything, and subsumes all other types.

Since the analysis runs in a browser as code is trying to execute,
both time and space are at a premium and must be minimized.
To be viable for deployment, the analysis must satisfy the following:

\begin{itemize}

\item Time and memory used must be linear in the size of the analyzed code.

\item Querying results for an expression must take near-constant time,
to avoid changing the performance characteristics of the compiler.

\item Results must be correct if only compiled code is analyzed.

\end{itemize}

Section~\ref{XXX} describes object types, Section~\ref{XXX} describes
generation of the type constraints which forms the static portion of
the analysis, and Section~\ref{XXX} describes type barriers and the
other runtime checks which form the dynamic portion of the analysis.

\subsection{Object Types}

To reason about the effects of property accesses, we need type information
for Javascript objects and their properties.
We associate every Javascript object with an {\it object type} $o$.
A type $t$ is an object if $O(t)$.
When $o \in T(v)$ for some expression $v$, then the possible values
for $v$ when it is executed include all Javascript objects with type $o$.

Types are assigned to Javascript objects according to their prototype:
all Javascript objects with the same type have the same prototype.
Additionally, objects with the same prototype have the same type,
except for plain \code{Object}, \code{Array} and \code{Function} objects.
\code{Object} and \code{Array} objects have the same type if they were
allocated at the same location in a script,
and \code{Function} objects have the same type if they are closures
for the same script.

The type of an object is independent from the properties it has;
objects which are structurally identical may have different types,
and objects with the same type may have different structures.
This is crucial for efficient analysis.
Properties can be added or deleted to Javascript objects at any time,
and using structural typing would make an object's type a
flow-sensitive property.

Instead, for each object type we compute the {\it possible} properties
which objects of that type can have, and the possible types of those
properties.
These are represented as type sets $Prop(o,f)$ and $Index(o)$.
$Prop(o,f)$ captures the possible types of a non-integer property
$f$ for objects with type $o$, while $Index(o)$ captures the possible
types of all integer properties of all objects with type $o$.

\subsection{Type Constraints}

We model the semantics of Javascript and how types flow through the
program as constraints between type sets.
This modeling is {\it incomplete}: it does not account for all possible
behaviors of Javascript expressions and statements.
All behaviors excluded by the type constraints must be detected at runtime
and their effect on types in the program dynamically recorded.

We describe the constraints and checks required for a simplified form
of the language: assignment, addition, property accesses, element accesses,
and function calls between variables.

\subsubsection{\code{x = y}}

Assignments in Javascript are completely modeled by a subset constraint
$T(y) \subseteq T(x)$.

\begin{equation*}
\frac{t \in T(y)}{t \in T(x)}
\end{equation*}

\subsubsection{\code{x = y + z}}

Addition in Javascript is very complicated. It is defined for any
combination of values, can perform either a numeric addition or
string concatenation, and can even perform function calls if either of
its operands is an object (calling their \code{valueOf} or
\code{toString} members, producing a number or string).

Using incomplete modeling lets us cut through this complexity.
The vast majority of dynamic additions in Javascript programs (NUMBERS)
are adding two numbers or concatenating two strings.
We statically model exactly these cases, and use runtime checks to monitor
the results produced by adding other combinations of values,
at little runtime cost.

Rules for addition of number and string values are below.

\begin{equation*}
\frac{int \in T(y) ~~~ int \in T(z)}{int \in T(x)}
\end{equation*}

\begin{equation*}
\frac{number \in T(y) ~~~ int \in T(z)}{number \in T(x)}
~~~~
\frac{int \in T(y) ~~~ number \in T(z)}{number \in T(x)}
\end{equation*}

\begin{equation*}
\frac{string \in T(y)}{string \in T(x)}
~~~~
\frac{string \in T(z)}{string \in T(x)}
\end{equation*}

\begin{equation*}
\frac{unknown \in T(y)}{unknown \in T(x)}
~~~~
\frac{unknown \in T(z)}{unknown \in T(x)}
\end{equation*}

The above rules are themselves incomplete for addition of two integers:
the result will be marked as an integer, ignoring the possibility of
integer overflow.
When adding two integers overflows, the result is not expressible in
32 bits, and has type \code{number}.
Overflow is extremely rare, and accounting for it statically would require
us to mark the result of all additions as arbitrary numbers,
except in the limited cases where we can prove no overflow is possible.

Ignoring overflow statically forces us to use runtime checks when overflows
occur.
There is no extra runtime cost associated with these checks, as
generating code for integer additions requires an overflow check regardless.

\subsubsection{\code{x = y.f}}

TODO

\begin{eqnarray*}
\frac{t \in T(y) ~~~ O(t) ~~~ t' \in Prop(t,f)}{t' \in T(x)}
\end{eqnarray*}

\subsubsection{\code{y.f = x}}

TODO --- unknown type

\begin{eqnarray*}
\frac{t \in T(x) ~~~ t' \in T(y) ~~~ O(t')}{t \in Prop(t',f)}
\end{eqnarray*}

\subsubsection{\code{x = y[z]}, \code{y[z] = x}}

\begin{eqnarray*}
\frac{t \in T(y) ~~~ O(t) ~~~ t' \in Index(t)}{t' \in T(x)}
\end{eqnarray*}

\begin{eqnarray*}
\frac{t \in T(x) ~~~ t' \in T(y) ~~~ O(t')}{t \in Index(t')}
\end{eqnarray*}

\subsubsection{\code{x = y(z)}}

TODO --- skip this?

\begin{eqnarray*}
\frac{f \in T(y) ~~~ F(f) ~~~ t \in T(z)}{t \in T(arg(f, 0))}
\end{eqnarray*}

\begin{eqnarray*}
\frac{f \in T(y) ~~~ F(f) ~~~ t \in T(retval(f))}{t \in T(x)}
\end{eqnarray*}

\subsection{Type Barriers}

TODO

As described in Section~\ref{XXX}, type barriers are a form of runtime
check designed to retain precision when a program contains polymorphic code.

TODO

For any subset constraint $A \subseteq B$, we are free to restrict
propagation of types which are in $A$ but have never been observed for $B$,
so long as we include a runtime check for values read into $B$ and update
it with any newly observed types.

The presence or absence of type barriers for a given subset constraint
is not monotonic with respect to the contents of the type sets in the program.
As new types are discovered, new type barriers may be required, but existing
ones may become unnecessary.
However, it is always safe to perform the runtime check for a given barrier,
albeit less efficient.

\subsection{Interpreter Warmup}

TODO

\subsection{Supplemental Analysis}

TODO
